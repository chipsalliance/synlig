#!/usr/bin/env python3
"""Executes FuseSoC for each of the cores in dependency graph and stores results
It uses a DOT file as input (with a dependecy graph generated by FuseSoC),
and writes results to 'result.txt' and 'graph.dot'

Usage:
    ./iterate_cores.py ./dependency_graph.dot
"""
from subprocess import run
from enum import Enum
import argparse
import pygraphviz as pgv
import networkx as nx

parser = argparse.ArgumentParser()
parser.add_argument('dot', help='Dot file with dependency graph generated using "fusesoc dep graph â€¦"')
args = parser.parse_args()

dot_graph = pgv.AGraph(args.dot)
graph = nx.DiGraph(dot_graph)

class Status(Enum):
    FAILED = 1
    PASSED = 2
    UNKNOWN = 3
    SKIPPED = 4

nx.set_node_attributes(graph, {node: Status.UNKNOWN for node in graph}, 'status')
root = [node for node, degree in graph.in_degree() if degree == 0][0]
nodes = reversed(list(nx.topological_sort(graph)))

def process_node(graph, node):
    status = nx.get_node_attributes(graph, 'status')[node]
    if status == Status.UNKNOWN:
        cmd = ['fusesoc', '--cores-root=.', 'run', '--flag=fileset_ip', '--target=default', '--build', '--tool=yosys', node]
        print('running: ' + ' '.join(cmd))
        fuse = run(cmd, shell=False, capture_output=False)
        if fuse.returncode == 0:
            nx.set_node_attributes(graph, {node: Status.PASSED}, 'status')
        else:
            nx.set_node_attributes(graph, {node: Status.FAILED}, 'status')

for node in nodes:
    children_names = list(graph[node])
    # If any of the children failed, skip this node
    for child in children_names:
        status = nx.get_node_attributes(graph, 'status')[child]
        if  status == Status.FAILED or status == Status.SKIPPED:
            nx.set_node_attributes(graph, {node: Status.SKIPPED}, 'status')
            break
    if nx.get_node_attributes(graph, 'status')[node] == Status.SKIPPED:
        continue
    process_node(graph, node)

# write markdown table with results
with open('result.txt', 'w') as f:
    f.write('| Name | Result |\n')
    f.write('|------|--------|\n')

    status_labels = {
        Status.PASSED: ':heavy_check_mark: PASSED',
        Status.FAILED: ':x: FAILED',
        Status.SKIPPED: ':heavy_minus_sign: SKIPPED',
    }
    for node in graph:
        status = nx.get_node_attributes(graph, 'status')[node]
        status_label = status_labels.get(status, status.name)
        f.write(f'| {node} | {status_label} |\n')

    passed = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.PASSED}
    failed = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.FAILED}
    skipped = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.SKIPPED}

    f.write('\n')
    f.write('|  |  |\n')
    f.write('|--|--|\n')
    f.write(f'| PASSED | {len(passed)} |\n')
    f.write(f'| FAILED | {len(failed)} |\n')
    f.write(f'| SKIPPED | {len(skipped)} |\n')
    f.write('\n')

    failed_deps = {str(fail): list(graph.predecessors(fail)) for fail in failed} 
    f.write('|Failed node| Used by | |\n')
    f.write('|--|--|--|\n')
    # sort failed nodes by the number of nodes that depend on that node, descending
    # limit the result to 10 entries
    result_limit = 10
    for dependency, predecessors in sorted(failed_deps.items(), key=lambda item: len(item[1]), reverse=True)[:result_limit]:
        pred = ', '.join(predecessors)
        f.write(f'|{dependency}|{pred}|{len(predecessors)}|\n')
    f.write('\n')
    f.write(f'(limited to {result_limit} results)\n')


# set node colors and status attributes
for node in graph:
    status = nx.get_node_attributes(graph, 'status')[node]
    if status == Status.FAILED:
        nx.set_node_attributes(graph, {node: 'red'}, 'fillcolor')
        nx.set_node_attributes(graph, {node: 'filled'}, 'style')
    if status == Status.PASSED:
        nx.set_node_attributes(graph, {node: 'lightblue'}, 'fillcolor')
        nx.set_node_attributes(graph, {node: 'filled'}, 'style')

    nx.set_node_attributes(graph, {node: status.name}, 'status')

graph.graph['graph']={'rankdir':'LR'}
nx.drawing.nx_agraph.write_dot(graph, 'graph.dot')
